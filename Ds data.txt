[8/14, 5:03 AM] 43: #include <stdio.h>
#include <string.h>

// Define a structure to hold student da
ta
struct Student {
    int rollNumber;
    char name[50];
    float result;
};

// Function to sort students by their result in ascending order
void sortStudentsByResult(struct Student students[], int n) {
    struct Student temp;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (students[j].result > students[j + 1].result) {
                // Swap the students
                temp = students[j];
                students[j] = students[j + 1];
                students[j + 1] = temp;
            }
        }
    }
}

int main() {
    // Declare an array of 10 Student structures
    struct Student students[10];

    // Input data for each student
    for (int i = 0; i < 10; i++) {
        printf("Enter details for student %d\n", i + 1);
        
        printf("Roll Number: ");
        scanf("%d", &students[i].rollNumber);
        
        printf("Name: ");
        scanf("%s", students[i].name);  // Note: this won't handle spaces in names
        
        printf("Result: ");
        scanf("%f", &students[i].result);
        
        printf("\n");
    }

    // Sort the students by their result
    sortStudentsByResult(students, 10);

    // Display the data for each student
    printf("Details of 10 students (sorted by result):\n");
    for (int i = 0; i < 10; i++) {
        printf("Student %d\n", i + 1);
        printf("Roll Number: %d\n", students[i].rollNumber);
        printf("Name: %s\n", students[i].name);
        printf("Result: %.2f\n", students[i].result);
        printf("\n");
    }

    return 0;
}
[8/14, 5:03 AM] 43: #include <stdio.h>

#define MAX 10

int count = 0;

// Creating a stack
struct stack {
  int items[MAX];
  int top;
};
typedef struct stack st;

void createEmptyStack(st *s) {
  s->top = -1;
}

// Check if the stack is full
int isfull(st *s) {
  if (s->top == MAX - 1)
    return 1;
  else
    return 0;
}

// Check if the stack is empty
int isempty(st *s) {
  if (s->top == -1)
    return 1;
  else
    return 0;
}

// Add elements into stack
void push(st *s, int newitem) {
  if (isfull(s)) {
    printf("STACK FULL\n");
  } else {
    s->top++;
    s->items[s->top] = newitem;
  }
  count++;
}

// Remove element from stack
void pop(st *s) {
  if (isempty(s)) {
    printf("\nSTACK EMPTY\n");
  } else {
    printf("Item popped= %d\n", s->items[s->top]);
    s->top--;
  }
  count--;
}

// Print elements of stack
void printStack(st *s) {
  printf("Stack: ");
  for (int i = 0; i <= s->top; i++) {
    printf("%d ", s->items[i]);
  }
  printf("\n");
}

// Driver code
int main() {
  st s;
  int choice, value;

  createEmptyStack(&s);

  while (1) {
    printf("Enter 1 to push, 2 to pop, 3 to print stack, 0 to exit: ");
    scanf("%d", &choice);

    switch (choice) {
      case 1:
        printf("Enter value to push: ");
        scanf("%d", &value);
        push(&s, value);
        break;
      case 2:
        pop(&s);
        break;
      case 3:
        printStack(&s);
        break;
      case 0:
        return 0;
      default:
        printf("Invalid choice, please try again.\n");
    }
  }

  return 0;
}
[8/14, 5:04 AM] 43: #include <stdio.h>
#define SIZE 5

void enQueue(int);
void deQueue();
void display();

int items[SIZE], front = -1, rear = -1;

int main() {
  int choice, value;
  while (1) {
    printf("\n\nQueue Operations Menu:\n");
    printf("1. EnQueue\n");
    printf("2. DeQueue\n");
    printf("3. Display\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);

    switch (choice) {
      case 1:
        printf("Enter the value to be enqueued: ");
        scanf("%d", &value);
        enQueue(value);
        break;
      case 2:
        deQueue();
        break;
      case 3:
        display();
        break;
      case 4:
        return 0;
      default:
        printf("Invalid choice! Please enter again.\n");
    }
  }
  return 0;
}

void enQueue(int value) {
  if (rear == SIZE - 1)
    printf("\nQueue is Full!!");
  else {
    if (front == -1)
      front = 0;
    rear++;
    items[rear] = value;
    printf("\nInserted -> %d", value);
  }
}

void deQueue() {
  if (front == -1)
    printf("\nQueue is Empty!!");
  else {
    printf("\nDeleted : %d", items[front]);
    front++;
    if (front > rear)
      front = rear = -1;
  }
}

// Function to print the queue
void display() {
  if (rear == -1)
    printf("\nQueue is Empty!!!");
  else {
    int i;
    printf("\nQueue elements are:\n");
    for (i = front; i <= rear; i++)
      printf("%d  ", items[i]);
  }
  printf("\n");
}
[8/14, 5:04 AM] 43: #include <stdio.h>

#define SIZE 5

int items[SIZE];
int front = -1, rear = -1;

int isFull();
int isEmpty();
void enQueue(int element);
int deQueue();
void display();

int main() {
  int choice, value;

  while (1) {
    printf("\n\nCircular Queue Menu\n");
    printf("1. EnQueue\n");
    printf("2. DeQueue\n");
    printf("3. Display\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);

    switch (choice) {
      case 1:
        printf("Enter the value to be inserted: ");
        scanf("%d", &value);
        enQueue(value);
        break;
      case 2:
        deQueue();
        break;
      case 3:
        display();
        break;
      case 4:
        return 0;
      default:
        printf("\nInvalid choice! Please enter a valid choice.\n");
    }
  }

  return 0;
}

// Check if the queue is full
int isFull() {
  if ((front == rear + 1) || (front == 0 && rear == SIZE - 1)) return 1;
  return 0;
}

// Check if the queue is empty
int isEmpty() {
  if (front == -1) return 1;
  return 0;
}

// Adding an element
void enQueue(int element) {
  if (isFull())
    printf("\nQueue is full!!\n");
  else {
    if (front == -1) front = 0;
    rear = (rear + 1) % SIZE;
    items[rear] = element;
    printf("\nInserted -> %d", element);
  }
}

// Removing an element
int deQueue() {
  int element;
  if (isEmpty()) {
    printf("\nQueue is empty!!\n");
    return -1;
  } else {
    element = items[front];
    if (front == rear) {
      front = -1;
      rear = -1;
    } else {
      front = (front + 1) % SIZE;
    }
    printf("\nDeleted element -> %d\n", element);
    return element;
  }
}

// Display the queue
void display() {
  int i;
  if (isEmpty())
    printf("\nEmpty Queue\n");
  else {
    printf("\nFront -> %d", front);
    printf("\nItems -> ");
    for (i = front; i != rear; i = (i + 1) % SIZE) {
      printf("%d ", items[i]);
    }
    printf("%d ", items[i]);
    printf("\nRear -> %d\n", rear);
  }
}
[8/14, 5:06 AM] 43: #include <stdio.h>
#include <stdlib.h>

#define MAX 100

typedef struct {
    int data[MAX];
    int front;
    int rear;
} Queue;

void initializeQueue(Queue *q);
int isFull(Queue *q);
int isEmpty(Queue *q);
void enqueue(Queue *q, int value);
int dequeue(Queue *q);
void display(Queue *q);

int main() {
    Queue sq, rq;
    int choice, age;

    initializeQueue(&sq);
    initializeQueue(&rq);

    while (1) {
        printf("\nPriority Queue Menu:\n");
        printf("1. Enqueue\n");
        printf("2. Dequeue\n");
        printf("3. Display\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter age to enqueue: ");
                scanf("%d", &age);
                if (age >= 60) {
                    enqueue(&sq, age);
                } else {
                    enqueue(&rq, age);
                }
                break;
            case 2:
                if (!isEmpty(&sq)) {
                    dequeue(&sq);
                } else if (!isEmpty(&rq)) {
                    dequeue(&rq);
                } else {
                    printf("Both queues are empty!\n");
                }
                break;
            case 3:
                printf("Senior Citizens Queue: ");
                display(&sq);
                printf("Regular Queue: ");
                display(&rq);
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice! Please try again.\n");
        }
    }

    return 0;
}

void initializeQueue(Queue *q) {
    q->front = -1;
    q->rear = -1;
}

int isFull(Queue *q) {
    return (q->rear == MAX - 1);
}

int isEmpty(Queue *q) {
    return (q->front == -1 || q->front > q->rear);
}

void enqueue(Queue *q, int value) {
    if (isFull(q)) {
        printf("Queue is full!\n");
    } else {
        if (q->front == -1) q->front = 0;
        q->data[++q->rear] = value;
        printf("Enqueued: %d\n", value);
    }
}

int dequeue(Queue *q) {
    int value;
    if (isEmpty(q)) {
        printf("Queue is empty!\n");
        return -1;
    } else {
        value = q->data[q->front++];
        if (q->front > q->rear) {
            q->front = q->rear = -1;  // Reset the queue after dequeuing the last element
        }
        printf("Dequeued: %d\n", value);
        return value;
    }
}

void display(Queue *q) {
    if (isEmpty(q)) {
        printf("Queue is empty!\n");
    } else {
        for (int i = q->front; i <= q->rear; i++) {
            printf("%d ", q->data[i]);
        }
        printf("\n");
    }
}
[8/14, 5:13 AM] 43: #include <stdio.h>

#define SIZE 7  // Define the size of the array

int binarySearch(int array[], int size, int x);

int main(void) {
    int array[SIZE] = {3, 4, 5, 6, 7, 8, 9};  // Initialize array with predefined size
    int x;

    // Display the array
    printf("Array elements: ");
    for (int i = 0; i < SIZE; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");

    // Get the element to search for from the user
    printf("Enter the element to search: ");
    scanf("%d", &x);

    // Perform binary search
    int result = binarySearch(array, SIZE, x);

    // Display the result
    if (result == -1) {
        printf("Element not found\n");
    } else {
        printf("Element is found at index %d\n", result);
    }

    return 0;
}

int binarySearch(int array[], int size, int x) {
    int low = 0;
    int high = size - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (array[mid] == x) {
            return mid;
        }

        if (array[mid] < x) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return -1;
}